import pandas as pd
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt
import json
import os
import time
import argparse
from typing import Tuple, List
plt.rcParams['svg.fonttype'] = 'none'


def read_cr_barcodes_summary(fn: str) -> Tuple[pd.DataFrame, pd.DataFrame]:
    """
    Reads singlecell.csv that is generated by 'cellranger-atac count' pipeline
    
    :param fn: Path to singlecell.csv
    :return: A tuple of two dataframes. The first dataframe is just a single row of
    the singlecell.csv where "NO_BARCODE" was found. The second dataframe contains
    the rest of the rows of the file sorted by total reads (descending order)
    """
    
    cellinfo = pd.read_csv(fn)
    nobc = cellinfo[cellinfo.barcode == 'NO_BARCODE']
    cellinfo = cellinfo[cellinfo.barcode != 'NO_BARCODE'].set_index('barcode')
    return nobc, cellinfo.sort_values(by='total', ascending=False)

def identify_cell_barcodes(a: np.ndarray, head_ignore: int=100,
                           tail_ignore: int=2000) -> int:
    """
    Calculate derivate of log (base 10) scaled sorted reads per barcodes using numpy.gradient
    Maxima of gradient is (excluding user specified head and tail intervals) is used
    to classify barcodes as either cell or non-cell
        
    :param a: Sorted (descending) log10 reads per barcode values
    :param head_ignore: Ignore gradients in first 'head_ignore' elements a
    :param head_ignore: Ignore gradients after 'tail_ignore' elements in a
    :return: The position of element in a upto which barcodes are regarded as cells.
    """
    
    x = np.array(list(range(1, len(a)+1)))
    grad = -1*np.gradient(a[head_ignore:tail_ignore])
    return x[head_ignore:tail_ignore][np.argmax(grad)] + 1

def mito_filter_cells(df: pd.DataFrame, cell_cutoff: int,
                      log_min_mito: float,
                      log_max_mito: float) -> List[str]:
    """
    Filter cells based on mitochondrial read percentages
        
    :param df: A dataframe containing atleast two columns: 'total' and 'mitochondrial'
               which contain toal and mitochondrial reads for each barcode (barcode as index).
               DataFrame should be sorted (in descending order) by 'total'
    :param cell_cutoff: Top n rows in dataframe to be considered as valid cells
    :param log_min_mito_percent: Cells with mitochondrial read percentage below this
                                 will be filtered out (to be provided in log2 scale)
    :param log_max_mito_percent: Cells with mitochondrial read percentage above this
                                 will be filtered out (to be provided in log2 scale)
    :return: List containing valid barcodes that passed the filter
    """
    
    mito_p = np.log2(100*df.mitochondrial/df.total)[:cell_cutoff]
    return list(mito_p[(mito_p < log_max_mito) & (mito_p > log_min_mito)].index)

def print_and_log(text, outfile, starttime=0):
    logtime = time.clock() - starttime
    if logtime < 60:
        logtime = "{:,}s".format(logtime)
    else:
        logtime = "{:,}m {:,}s".format(logtime // 60, logtime % 60)
    outfile.write("{} - {}\n".format(logtime, text))
    print("{} - {}".format(logtime, text))


if __name__=="__main__":
    parser=argparse.ArgumentParser()
    parser.add_argument("--crg_path",type=str,default=None,help="the cellranger outputs from cellranger-atac counts")
    parser.add_argument("--samples",nargs="+",type=str,default=None,help="the sample in crg_path")
    parser.add_argument("--excluded_path",type=str,default=None,help="the path from clean_barcode_multiplets_1.1")
    parser.add_argument("--outdir",type=str,default="output")
    parser.add_argument("--head_ignore",type=int,default=5000)
    parser.add_argument("--tail_ignore",type=int,default=50000)

    args=parser.parse_args()
    if not os.path.exists(args.outdir):
        os.makedirs(args.outdir)
        
    mito_max, mito_min = 2.7, -2.7
    sample_barcodes = {}

    samples_list=os.listdir(args.crg_path)
    samples=args.samples

    for sample in samples:
        assert sample in samples_list
        starttime = time.clock()
        logout=open(os.path.join(args.outdir,str(args.head_ignore)+"_"+str(args.tail_ignore)+"_{}_summary.txt".format(sample)),"w")
        no_bc, barcode_info = read_cr_barcodes_summary("{}/{}/outs/singlecell.csv".format(args.crg_path,sample))
        print ()
        print_and_log("INFO ({}): Total barcodes: {}".format(sample,len(barcode_info)),logout,starttime)
        print_and_log("INFO ({}): Reads without barcodes: {}".format(sample,no_bc.total.values[0]),logout,starttime)
        print_and_log("INFO ({}): Reads with barcodes: {}".format(sample,barcode_info.total.values.sum()),logout,starttime)
        cutoff_pos = identify_cell_barcodes(np.log10(barcode_info.total),head_ignore=args.head_ignore,tail_ignore=args.tail_ignore)
    
        print_and_log("INFO ({}): Number of barcodes considered valid: {}".format(sample,cutoff_pos),logout,starttime)
        print_and_log("INFO ({}): Minimum reads in valid barcodes : {}".format(sample,barcode_info.total[cutoff_pos]),logout,starttime)
        mito_filtered_cells = mito_filter_cells(barcode_info, cutoff_pos, mito_min, mito_max)
        print_and_log("INFO ({}): Number of valid barcodes after mitochondrial read filtering: {}".format(sample,len(mito_filtered_cells)),logout,starttime)

        multiplet_fn = "{}/{}/excluded_barcodes.csv".format(args.excluded_path,sample)
        multiplet_filtered_cells = list(set(barcode_info[:cutoff_pos].index).difference(
            pd.read_csv(multiplet_fn)['Excluded Barcode'].values))
        print_and_log("INFO ({}): Number of valid barcodes after multiplet filtering : {}".format(sample,len(multiplet_filtered_cells)),logout,starttime)

        final_barcodes = list(set(multiplet_filtered_cells).intersection(mito_filtered_cells))
        final_barcodes = list(pd.DataFrame({'x': final_barcodes, 'y': np.repeat(1, len(final_barcodes))}
                     ).set_index('x').reindex(barcode_info.index).dropna().index)
        print_and_log("INFO ({}): Final number of valid barcodes: {}".format(sample,len(final_barcodes)),logout,starttime)
        
        fig, axis = plt.subplots(1, 3, figsize=(13,3.5))
    
        vals = barcode_info.total
        xpos = np.array(list(range(1, len(barcode_info)+1)))
    
        ax = axis[0]
        ax.plot(xpos[:cutoff_pos], vals[:cutoff_pos], label='Cells', lw=4, c='crimson', rasterized=True)
        ax.plot(xpos[cutoff_pos:], vals[cutoff_pos:], label='Non-cell\nbarcodes', lw=2, c='grey', rasterized=True)
        ax.fill_between(range(1, cutoff_pos+1), 0, vals[:cutoff_pos], color='salmon', alpha=0.2)
        ax.axvline(cutoff_pos, c='k', ls='--')
        ax.text(cutoff_pos-50, vals[0]-vals[0]/10, cutoff_pos, fontsize=15, va='center', ha='right')
        ax.text(cutoff_pos/15, vals[0]/1000,
            f"{(100*vals[:cutoff_pos].sum()/vals.sum()).round(1)}%",
            fontsize=15, va='center', ha='center')
        ax.set_yscale('log', basey=10)
        ax.set_xscale('log', basex=10)
        ax.legend(loc="upper right", frameon=False, fontsize=13)
    
        ax = axis[1]
        cell_vals = np.log10(vals[:cutoff_pos])
        noncell_vals = np.log10(vals[cutoff_pos:cutoff_pos*2])
        ax.hist(noncell_vals, bins=50, range=(noncell_vals.min(),cell_vals.max()),
                color='grey', label='Non-cell', rasterized=True)
        ax.hist(cell_vals, bins=50, range=(noncell_vals.min(),cell_vals.max()),
                color='crimson', label='Cell', rasterized=True)  
        ax.axvline(np.log10(barcode_info.total[cutoff_pos]), c='k', ls='--')
        ax.legend(frameon=False, fontsize=13)
    
        ax = axis[2]
        ax.axhspan(mito_max, 4.1, alpha=0.2, color='grey')
        ax.axhspan(mito_min, -4.1, alpha=0.2, color='grey')
    
        poor_cells1 = set(barcode_info.index[:cutoff_pos]).difference(mito_filtered_cells)
        poor_cells2 = set(barcode_info.index[:cutoff_pos]).difference(multiplet_filtered_cells)
        mito_p = np.log2(100*barcode_info.mitochondrial/vals)
        mito_p[mito_p < -4] = -4
        mito_p[mito_p > 4] = 4
        ax.scatter(vals.reindex(final_barcodes), mito_p.reindex(final_barcodes), c='crimson', s=5, rasterized=True)
        ax.scatter(vals.reindex(poor_cells1), mito_p.reindex(poor_cells1), c='steelblue', s=40, rasterized=True)
        ax.scatter(vals.reindex(poor_cells2), mito_p.reindex(poor_cells2), c='black', s=20, rasterized=True)
        ax.set_xscale('log', basex=10)
        ax.axhline(mito_max, c='k', ls='--')
        ax.axhline(mito_min, c='k', ls='--')
        ax.set_ylim((-4.1, 4.1))
        ax.set_xlim((vals[cutoff_pos+1], vals[0]+vals[0]*0.05))
    
        xlabels = ["# Barcodes", "Fragments/Cell (log10 scale)", "Fragments/Cell" ]
        ylabels = ["Fragments/Cell", "Frequency", "% mitochondrial (log2 scale)"]
        for i in range(len(axis)):
            ax = axis[i]
            ax.set_xlabel(xlabels[i], fontsize=14)
            ax.set_ylabel(ylabels[i], fontsize=14)
    
        plt.suptitle("{} ({})".format(sample,len(final_barcodes)), y=1.05, fontsize=16)
        plt.tight_layout()
        filename=args.outdir+"/"+"{}_filter_barcode.pdf".format(sample)
        plt.savefig(filename, dpi=80,bbox_inches='tight')
        sample_barcodes[sample] = final_barcodes    
    
    with open(os.path.join(args.outdir,"barcodes.json"), 'w') as OUT:
        json.dump(sample_barcodes, OUT, indent=True)
